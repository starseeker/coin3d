/**************************************************************************\
 * Copyright (c) Kongsberg Oil & Gas Technologies AS
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * 
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 
 * Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
\**************************************************************************/

#include "utils/test_common.h"

using namespace CoinTestUtils;

// Complete migrated tests for base module

// Tests for SbBSPTree (from src/base/SbBSPTree.cpp)



TEST_CASE("SbBSPTree tests", "[base][SbBSPTree]") {
    CoinTestFixture fixture;


    SECTION("initialized") {
{
  SbBSPTree bsp;
  SbVec3f p0(0.0f, 0.0f, 0.0f);
  SbVec3f p1(1.0f, 0.0f, 0.0f);
  SbVec3f p2(2.0f, 0.0f, 0.0f);
  void * userdata0 = reinterpret_cast<void*> (&p0); 
  void * userdata1 = reinterpret_cast<void*> (&p1); 
  void * userdata2 = reinterpret_cast<void*> (&p2); 

          CHECK_WITH_MESSAGE(bsp.addPoint(p0, userdata0) == 0, "unexpected index");
          CHECK_WITH_MESSAGE(bsp.addPoint(p1, userdata1) == 1, "unexpected index");
          CHECK_WITH_MESSAGE(bsp.addPoint(p2, userdata2) == 2, "unexpected index");
          CHECK_WITH_MESSAGE(bsp.addPoint(p2, userdata2) == 2, "unexpected index");
          CHECK_WITH_MESSAGE(bsp.numPoints() == 3, "wrong number of points in the tree");

          CHECK_WITH_MESSAGE(bsp.findPoint(p0) == 0, "wrong index");
          CHECK_WITH_MESSAGE(bsp.getUserData(0) == userdata0, "wrong userdata");
          CHECK_WITH_MESSAGE(bsp.findPoint(p1) == 1, "wrong index");
          CHECK_WITH_MESSAGE(bsp.getUserData(1) == userdata1, "wrong userdata");
          CHECK_WITH_MESSAGE(bsp.findPoint(p2) == 2, "wrong index");
          CHECK_WITH_MESSAGE(bsp.getUserData(2) == userdata2, "wrong userdata");

          CHECK_WITH_MESSAGE(bsp.numPoints() == 3, "wrong number of points in the tree");
          CHECK_WITH_MESSAGE(bsp.getPointsArrayPtr()[0] == p0, "wrong point at index 0");
          CHECK_WITH_MESSAGE(bsp.getPointsArrayPtr()[1] == p1, "wrong point at index 1");
          CHECK_WITH_MESSAGE(bsp.getPointsArrayPtr()[2] == p2, "wrong point at index 2");

          CHECK_WITH_MESSAGE(bsp.removePoint(p1) == 1, "unable to remove point");
          CHECK_WITH_MESSAGE(bsp.numPoints() == 2, "wrong number of points after removePoint().");
          CHECK_WITH_MESSAGE(bsp.getPointsArrayPtr()[0] == p0, "wrong point at index 0");
          CHECK_WITH_MESSAGE(bsp.getUserData(0) == userdata0, "wrong userdata");
          CHECK_WITH_MESSAGE(bsp.getPointsArrayPtr()[1] == p2, "wrong point at index 1");
          CHECK_WITH_MESSAGE(bsp.getUserData(1) == userdata2, "wrong userdata");

          CHECK_WITH_MESSAGE(bsp.removePoint(p0) >= 0, "unable to remove point");
          CHECK_WITH_MESSAGE(bsp.removePoint(p2) >= 0, "unable to remove point");
          CHECK_WITH_MESSAGE(bsp.numPoints() == 0, "wrong number of points after removing all points.");

    }
}

// Tests for SbBox3s (from src/base/SbBox3s.cpp)



TEST_CASE("SbBox3s tests", "[base][SbBox3s]") {
    CoinTestFixture fixture;

    SECTION("checkSize") { {
  SbVec3s min(1,2,3);
  SbVec3s max(3,4,5);

  SbVec3s diff = max - min;

  SbBox3s box(min, max);

  BOOST_CHECK_MESSAGE(box.getSize() == diff,
                      "Box has incorrect size");
    }
    SECTION("checkGetClosestPoint") { {
  SbVec3f point(1524 , 13794 , 851);
  SbVec3s min(1557, 3308, 850);
  SbVec3s max(3113, 30157, 1886);

  SbBox3s box(min, max);
  SbVec3f expected(1557, 13794, 851);

  BOOST_CHECK_MESSAGE(box.getClosestPoint(point) == expected,
                      "Closest point does not fit");

  SbVec3s sizes = box.getSize();
  SbVec3f expectedCenterQuery(sizes[0]/2.0f, sizes[1]/2.0f, max[2]);

  BOOST_CHECK_MESSAGE(box.getClosestPoint(box.getCenter()) == expectedCenterQuery,
                      "Closest point for center query does not fit");
    }
}

// Tests for SbBox3i32 (from src/base/SbBox3i32.cpp)



TEST_CASE("SbBox3i32 tests", "[base][SbBox3i32]") {
    CoinTestFixture fixture;

    SECTION("checkSize") { {
  SbVec3i32 min(1,2,3);
  SbVec3i32 max(3,4,5);

  SbVec3i32 diff = max - min;

  SbBox3i32 box(min, max);

  BOOST_CHECK_MESSAGE(box.getSize() == diff,
                      "Box has incorrect size");
    }
    SECTION("checkGetClosestPoint") { {
  SbVec3f point(1524 , 13794 , 851);
  SbVec3i32 min(1557, 3308, 850);
  SbVec3i32 max(3113, 30157, 1886);

  SbBox3i32 box(min, max);
  SbVec3f expected(1557, 13794, 851);

  BOOST_CHECK_MESSAGE(box.getClosestPoint(point) == expected,
                      "Closest point does not fit");

  SbVec3i32 sizes = box.getSize();
  SbVec3f expectedCenterQuery(sizes[0]/2.0f, sizes[1]/2.0f, (float)max[2]);

  BOOST_CHECK_MESSAGE(box.getClosestPoint(box.getCenter()) == expectedCenterQuery,
                      "Closest point for center query does not fit");
    }
}

// Tests for rbptree (from src/base/rbptree.cpp)



TEST_CASE("rbptree tests", "[base][rbptree]") {
    CoinTestFixture fixture;



#define FILL_TIMES (50)
#define FILL_COUNT (10000)

    SECTION("rbptree_stress") {
{
  srand(123);
  cc_rbptree tree;
  cc_rbptree_init(&tree);

  int i;
  for (int c = 0; c < FILL_TIMES; ++c) {
    SbList<void *> values;
    for (i = 0; i < FILL_COUNT; ++i) {
      void * entry = reinterpret_cast<void *>(static_cast<uintptr_t>(rand()));
      cc_rbptree_insert(&tree, entry, NULL);
      values.append(entry);
    }
    BOOST_ASSERT(cc_rbptree_size(&tree) == FILL_COUNT);

    if ((c & 1) == 0) {
      for (i = (FILL_COUNT - 1); i >= 0; --i) cc_rbptree_remove(&tree, values[i]);
    } else {
      for (i = 0; i < FILL_COUNT; ++i) cc_rbptree_remove(&tree, values[i]);
    }
    BOOST_ASSERT(cc_rbptree_size(&tree) == 0);
  }

  for (int c = 0; c < FILL_TIMES; ++c) {
    SbList<void *> values;
    for (i = 0; i < FILL_COUNT; ++i) {
      void * entry = reinterpret_cast<void *>(static_cast<uintptr_t>(((c & 2) == 0) ? i : (FILL_COUNT - i)));
      cc_rbptree_insert(&tree, entry, NULL);
      values.append(entry);
    }
    BOOST_ASSERT(cc_rbptree_size(&tree) == FILL_COUNT);

    if ((c & 1) == 0) {
      for (i = (FILL_COUNT - 1); i >= 0; --i) cc_rbptree_remove(&tree, values[i]);
    } else {
      for (i = 0; i < FILL_COUNT; ++i) cc_rbptree_remove(&tree, values[i]);
    }
    BOOST_ASSERT(cc_rbptree_size(&tree) == 0);

  }


  cc_rbptree_clean(&tree);
    }
}

// Tests for SbPlane (from src/base/SbPlane.cpp)



TEST_CASE("SbPlane tests", "[base][SbPlane]") {
    CoinTestFixture fixture;


using namespace SIM::Coin::TestSuite;

    SECTION("signCorrect") {
{
  SbPlane plane1(SbVec3f(0.0, 0.0, 1.0), 3.0);
  SbPlane plane2(SbVec3f(1.0, 0.0, 0.0), 21.0);
  SbLine line;
  plane1.intersect(plane2, line); 

  SbVec3f intersect = line.getPosition();
  SbVec3f vec(21, 0, 3);

  check_compare(intersect,vec, "SbPlane SignCorrect", .1f);

    }
}

// Tests for SbDPRotation (from src/base/SbDPRotation.cpp)



TEST_CASE("SbDPRotation tests", "[base][SbDPRotation]") {
    CoinTestFixture fixture;


    SECTION("tgsCompliance") { {
  SbDPRotation v = SbRotationd(SbVec3d(0,1,2),3);
    }
}

// Tests for SbMatrix (from src/base/SbMatrix.cpp)



TEST_CASE("SbMatrix tests", "[base][SbMatrix]") {
    CoinTestFixture fixture;


    SECTION("constructFromSbDPMatrix") { {
  SbMatrixd a(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15);
  SbMatrix b;
  float c[]  = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
  b.setValue(c);
  SbMatrix d = SbMatrix(a);
  BOOST_CHECK_MESSAGE(b == d,
                      "Equality comparison failed!");
    }

    SECTION("multLeft") { {
  // Test data from test-code/SbMatrix/multLeft regression test
  SbMatrix rightmatrix = SbMatrix::identity();
  
  // Test matrix 1
  SbMatrix leftmatrix1(0.797f, -0.168f, -0.336f, 0.000f,
                       0.663f, 1.357f, 1.134f, 0.000f,
                       0.080f, -0.446f, 0.396f, 0.000f,
                       -0.239f, 0.141f, -2.007f, 1.000f);
  rightmatrix.multLeft(leftmatrix1);
  
  // Check first multiplication result
          CHECK_WITH_MESSAGE(fabs(rightmatrix[0][0] - 0.797f) < 0.001f, "multLeft result incorrect");
          CHECK_WITH_MESSAGE(fabs(rightmatrix[1][1] - 1.357f) < 0.001f, "multLeft result incorrect");
          CHECK_WITH_MESSAGE(fabs(rightmatrix[3][3] - 1.000f) < 0.001f, "multLeft result incorrect");
  
  // Test matrix 2
  SbMatrix leftmatrix2(0.943f, 0.260f, -0.393f, 0.000f,
                       -0.657f, 1.588f, 0.725f, 0.000f,
                       -0.837f, 0.270f, -1.403f, 0.000f,
                       -1.028f, 0.373f, -1.675f, 1.000f);
  rightmatrix.multLeft(leftmatrix2);
  
  // Check second multiplication result (cumulative)
          CHECK_WITH_MESSAGE(fabs(rightmatrix[0][0] - 0.893f) < 0.01f, "multLeft cumulative result incorrect");
          CHECK_WITH_MESSAGE(fabs(rightmatrix[1][1] - 1.942f) < 0.01f, "multLeft cumulative result incorrect");
    }

    SECTION("multRight") { {
  // Test data from test-code/SbMatrix/multRight regression test
  SbMatrix leftmatrix = SbMatrix::identity();
  
  // Test matrix 1
  SbMatrix rightmatrix1(0.797f, -0.168f, -0.336f, 0.000f,
                        0.663f, 1.357f, 1.134f, 0.000f,
                        0.080f, -0.446f, 0.396f, 0.000f,
                        -0.239f, 0.141f, -2.007f, 1.000f);
  leftmatrix.multRight(rightmatrix1);
  
  // Check first multiplication result
          CHECK_WITH_MESSAGE(fabs(leftmatrix[0][0] - 0.797f) < 0.001f, "multRight result incorrect");
          CHECK_WITH_MESSAGE(fabs(leftmatrix[1][1] - 1.357f) < 0.001f, "multRight result incorrect");
          CHECK_WITH_MESSAGE(fabs(leftmatrix[3][3] - 1.000f) < 0.001f, "multRight result incorrect");
  
  // Test matrix 2
  SbMatrix rightmatrix2(0.943f, 0.260f, -0.393f, 0.000f,
                        -0.657f, 1.588f, 0.725f, 0.000f,
                        -0.837f, 0.270f, -1.403f, 0.000f,
                        -1.028f, 0.373f, -1.675f, 1.000f);
  leftmatrix.multRight(rightmatrix2);
  
  // Check second multiplication result (cumulative) 
          CHECK_WITH_MESSAGE(fabs(leftmatrix[0][0] - 1.143f) < 0.01f, "multRight cumulative result incorrect");
          CHECK_WITH_MESSAGE(fabs(leftmatrix[0][1] + 0.150f) < 0.01f, "multRight cumulative result incorrect");
    }

    SECTION("getTransform") { {
  // Test matrix decomposition functionality from test-code/SbMatrix/getTransform
  SbMatrix matrix(0.797f, -0.168f, -0.336f, 0.000f,
                  0.663f, 1.357f, 1.134f, 0.000f,
                  0.080f, -0.446f, 0.396f, 0.000f,
                  -0.239f, 0.141f, -2.007f, 1.000f);
  
  SbVec3f trans;
  SbRotation rot;
  SbVec3f scale;
  SbRotation so;
  matrix.getTransform(trans, rot, scale, so);
  
  // Verify that decomposition works and components are reasonable
          CHECK_WITH_MESSAGE(trans.length() < 10.0f, "Translation component seems unreasonably large");
          CHECK_WITH_MESSAGE(scale.length() > 0.1f, "Scale component seems unreasonably small");
  
  // Test round-trip: reconstruct matrix from components
  SbMatrix reconstructed;
  reconstructed.setTransform(trans, rot, scale, so);
  
  // Check that reconstruction is reasonably close to original
  for (int i = 0; i < 4; i++) {
    for (int j = 0; j < 4; j++) {
      float diff = fabs(matrix[i][j] - reconstructed[i][j]);
              CHECK_WITH_MESSAGE(diff < 0.1f, "Matrix reconstruction failed");
    }
  }
    }
}

// Tests for SbBox2s (from src/base/SbBox2s.cpp)



TEST_CASE("SbBox2s tests", "[base][SbBox2s]") {
    CoinTestFixture fixture;

    SECTION("checkSize") { {
  SbVec2s min(1,2);
  SbVec2s max(3,4);

  SbVec2s diff = max - min;

  
  SbBox2s box(min, max);

  BOOST_CHECK_MESSAGE(box.getSize() == diff,
                      "Box has incorrect size");

    }
}

// Tests for SbVec3d (from src/base/SbVec3d.cpp)



TEST_CASE("SbVec3d tests", "[base][SbVec3d]") {
    CoinTestFixture fixture;

typedef SbVec3d ToTest;
    SECTION("toString") { {
  ToTest val(1.0/3,2,3);
  SbString str("0.3333333333333333 2 3");
  BOOST_CHECK_MESSAGE(str == val.toString(),
                      std::string("Mismatch between ") +  val.toString().getString() + " and control string " + str.getString());

    }

    SECTION("fromString") { {
  ToTest foo;
  SbString test = "0.3333333333333333 -2 -3.0";
  ToTest trueVal(0.3333333333333333,-2,-3);
  SbBool conversionOk = foo.fromString(test);
  BOOST_CHECK_MESSAGE(conversionOk && trueVal == foo,
                      std::string("Mismatch between ") +  foo.toString().getString() + " and control " + trueVal.toString().getString());
    }
}

// Tests for SbBox2f (from src/base/SbBox2f.cpp)



TEST_CASE("SbBox2f tests", "[base][SbBox2f]") {
    CoinTestFixture fixture;

    SECTION("checkSize") { {
  SbVec2f min(1,2);
  SbVec2f max(3,4);

  SbVec2f diff = max - min;

  SbBox2f box(min, max);

  BOOST_CHECK_MESSAGE(box.getSize() == diff,
                      "Box has incorrect size");
    }
    SECTION("checkGetClosestPoint") { {
  SbVec2f point(1524, 13794);
  SbVec2f min(1557, 3308);
  SbVec2f max(3113, 30157);

  SbBox2f box(min, max);
  SbVec2f expected(1557, 13794);

  BOOST_CHECK_MESSAGE(box.getClosestPoint(point) == expected,
                      "Closest point does not fit");

  SbVec2f sizes = box.getSize();
  SbVec2f expectedCenterQuery(max[0], sizes[1] / 2.0f);

  BOOST_CHECK_MESSAGE(box.getClosestPoint(box.getCenter()) == expectedCenterQuery,
                      "Closest point for center query does not fit");
    }
}

// Tests for SbBox2i32 (from src/base/SbBox2i32.cpp)



TEST_CASE("SbBox2i32 tests", "[base][SbBox2i32]") {
    CoinTestFixture fixture;

    SECTION("checkSize") { {
  SbVec2i32 min(1,2);
  SbVec2i32 max(3,4);

  SbVec2i32 diff = max - min;

  
  SbBox2i32 box(min, max);

  BOOST_CHECK_MESSAGE(box.getSize() == diff,
                      "Box has incorrect size");

    }
}

// Tests for SbDPMatrix (from src/base/SbDPMatrix.cpp)



TEST_CASE("SbDPMatrix tests", "[base][SbDPMatrix]") {
    CoinTestFixture fixture;


    SECTION("constructFromSbMatrix") { {
  SbMatrix a(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15);
  SbMatrixd b;
  double c[]  = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
  b.setValue(c);
  SbDPMatrix d = SbMatrixd(a);
  BOOST_CHECK_MESSAGE(b == d,
                      "Equality comparison failed!");
    }
}

// Tests for SbRotation (from src/base/SbRotation.cpp)



TEST_CASE("SbRotation tests", "[base][SbRotation]") {
    CoinTestFixture fixture;


typedef SbRotation ToTest;
    SECTION("operatorBrackets") {
{
  const int FLOAT_SENSITIVITY = 1;
  const float SQRT2 = sqrt(2.f)/2.f;
  SbRotation rot(0,-SQRT2,0,SQRT2);

  for (int i=0;i<4;++i) {
    int premultiply = ((i&0x1)*((i&0x2)-1));
    float testVal = premultiply*SQRT2;
    BOOST_CHECK_MESSAGE(
                        floatEquals(testVal,rot[i],FLOAT_SENSITIVITY),
                        std::string("Wrong value when trying to access value #")
                        + std::to_string(i)
                        + ": "
                        + std::to_string(rot[i]) +
                        " == "
                        + std::to_string(testVal)
                        );
  }
    }

    SECTION("toString") { {
  ToTest val(SbVec3f(0, -1, 0),  1);
  SbString str("0 -1 0  1");
  SbVec4f expected(0.f, -1.f, 0.f, 1.f), actual;
  sscanf(val.toString().getString(), "%f %f %f  %f", &actual[0], &actual[1], &actual[2], &actual[3]);
          CHECK_WITH_MESSAGE(actual.equals(expected, 0.000001f),
                      std::string("Mismatch between ") +  val.toString().getString() + " and control string " + str.getString());

    }

    SECTION("fromString") { {
  ToTest foo;
  SbString test = "0 -1 0 1";
  ToTest trueVal(SbVec3f(0, -1, 0),  1);
  SbBool conversionOk = foo.fromString(test);
  BOOST_CHECK_MESSAGE(conversionOk && trueVal == foo,
                      std::string("Mismatch between ") +  foo.toString().getString() + " and control " + trueVal.toString().getString());
    }

    SECTION("fromInvalidString") { {
  ToTest foo;
  SbString test = "2.- 2 3 4";
  ToTest trueVal(1,2,3,4);
  SbBool conversionOk = foo.fromString(test);
  BOOST_CHECK_MESSAGE(conversionOk == FALSE,
                      std::string("Able to convert from ") + test.getString() + " which is not a valid " + SbTypeInfo<ToTest>::getTypeName() + " representation");
    }

    SECTION("multiplicationOperators") { {
  // Test data from test-code/SbRotation/SbRotation_mul_SbRotation regression test
  SbRotation r = SbRotation::identity();
  
  // Test rotation 1
  float v1[] = {-0.487f, -0.574f, 0.367f, -0.547f};
  SbRotation n1(v1);
  r *= n1;
  r = r * n1; // test this variant as well
  
  const float* result1 = r.getValue();
  // Expected result based on test-code regression test
          CHECK_WITH_MESSAGE(fabs(result1[0] - 0.532f) < 0.01f, "Rotation multiplication x component incorrect");
          CHECK_WITH_MESSAGE(fabs(result1[1] - 0.628f) < 0.01f, "Rotation multiplication y component incorrect");
          CHECK_WITH_MESSAGE(fabs(result1[2] + 0.401f) < 0.01f, "Rotation multiplication z component incorrect");
  
  // Test rotation 2
  float v2[] = {0.358f, -0.026f, 0.919f, 0.164f};
  SbRotation n2(v2);
  r *= n2;
  r = r * n2;
  
  const float* result2 = r.getValue();
  // Expected result based on test-code regression test
          CHECK_WITH_MESSAGE(fabs(result2[0] + 0.737f) < 0.01f, "Rotation multiplication cumulative x component incorrect");
          CHECK_WITH_MESSAGE(fabs(result2[1] + 0.383f) < 0.01f, "Rotation multiplication cumulative y component incorrect");
          CHECK_WITH_MESSAGE(fabs(result2[2] - 0.337f) < 0.01f, "Rotation multiplication cumulative z component incorrect");
    }

    SECTION("setValue_SbMatrix") { {
  // Test conversion from matrix to rotation - use a simpler rotation matrix
  SbMatrix matrix;
  matrix.setRotate(SbRotation(SbVec3f(0, 1, 0), M_PI/4)); // 45-degree rotation around Y-axis
  
  SbRotation rot;
  rot.setValue(matrix);
  
  // Verify the rotation is valid (normalized quaternion)
  const float* vals = rot.getValue();
  float magnitude = sqrt(vals[0]*vals[0] + vals[1]*vals[1] + vals[2]*vals[2] + vals[3]*vals[3]);
          CHECK_WITH_MESSAGE(fabs(magnitude - 1.0f) < 0.01f, "Rotation from matrix should be normalized");
  
  // Test round-trip: convert back to matrix
  SbMatrix result_matrix;
  rot.getValue(result_matrix);
  
  // The rotation part should be preserved (upper 3x3 minus scale)
  // This is a basic sanity check that the conversion makes sense
          CHECK_WITH_MESSAGE(result_matrix[3][3] == 1.0f, "Matrix from rotation should have 1.0 in [3][3]");
    }
}

// Tests for SbBox2d (from src/base/SbBox2d.cpp)



TEST_CASE("SbBox2d tests", "[base][SbBox2d]") {
    CoinTestFixture fixture;

    SECTION("checkSize") { {
  SbVec2d min(1,2);
  SbVec2d max(3,4);

  SbVec2d diff = max - min;

  SbBox2d box(min, max);

  BOOST_CHECK_MESSAGE(box.getSize() == diff,
                      "Box has incorrect size");
    }
    SECTION("checkGetClosestPoint") { {
  SbVec2d point(1524, 13794);
  SbVec2d min(1557, 3308);
  SbVec2d max(3113, 30157);

  SbBox2d box(min, max);
  SbVec2d expected(1557, 13794);

  BOOST_CHECK_MESSAGE(box.getClosestPoint(point) == expected,
                      "Closest point does not fit");

  SbVec2d sizes = box.getSize();
  SbVec2d expectedCenterQuery(max[0], sizes[1] / 2.0);

  BOOST_CHECK_MESSAGE(box.getClosestPoint(box.getCenter()) == expectedCenterQuery,
                      "Closest point for center query does not fit");
    }
}

// Tests for SbVec3f (from src/base/SbVec3f.cpp)



TEST_CASE("SbVec3f tests", "[base][SbVec3f]") {
    CoinTestFixture fixture;


typedef SbVec3f ToTest;
    SECTION("toString") { {
  ToTest val(1.0f/3,2,3);
  SbString str("0.33333334 2 3");
  BOOST_CHECK_MESSAGE(str == val.toString(),
                      std::string("Mismatch between ") +  val.toString().getString() + " and control string " + str.getString());

    }

    SECTION("fromString") { {
  ToTest foo;
  SbString test = "0.333333343 -2 -3.0";
  ToTest trueVal(0.333333343f,-2,-3);
  SbBool conversionOk = foo.fromString(test);
  BOOST_CHECK_MESSAGE(conversionOk && trueVal == foo,
                      std::string("Mismatch between ") +  foo.toString().getString() + " and control " + trueVal.toString().getString());
    }

    SECTION("fromInvalidString1") { {
  ToTest foo;
  SbString test = "a 2 3";
  SbBool conversionOk = foo.fromString(test);
  BOOST_CHECK_MESSAGE(conversionOk == FALSE,
                      std::string("Able to convert from ") + test.getString() + " which is not a valid " + SbTypeInfo<ToTest>::getTypeName() + " representation");
    }

    SECTION("fromInvalidString2") { {
  ToTest foo;
  SbString test = "1,2,3";
  SbBool conversionOk = foo.fromString(test);
  BOOST_CHECK_MESSAGE(conversionOk == FALSE,
                      std::string("Able to convert from ") + test.getString() + " which is not a valid " + SbTypeInfo<ToTest>::getTypeName() + " representation");
    }
}

// Tests for SbViewVolume (from src/base/SbViewVolume.cpp)



TEST_CASE("SbViewVolume tests", "[base][SbViewVolume]") {
    CoinTestFixture fixture;



    SECTION("intersect_ortho") {
{
  SbViewVolume vv;
  vv.ortho(-0.5, 0.5, -0.5, 0.5, -1, 10);
  SbBox3f box(0, 0, 0, 1, 1, 1);

  SbBox3f isect = vv.intersectionBox(box);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMin()[0], 0.0f);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMin()[1], 0.0f);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMin()[2], 0.0f);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMax()[0], 0.5f);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMax()[1], 0.5f);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMax()[2], 1.0f);
    }

    SECTION("intersect_bbox_inside_vv") {
{
  SbViewVolume vv;
  vv.ortho(-0.5, 0.5, -0.5, 0.5, -1, 10);
  SbBox3f box(-0.25, -0.25, -0.25, 0.25, 0.25, 0.25);

  SbBox3f isect = vv.intersectionBox(box);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMin()[0], -0.25);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMin()[1], -0.25f);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMin()[2], -0.25f);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMax()[0], 0.25f);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMax()[1], 0.25f);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMax()[2], 0.25f);
    }

    SECTION("intersect_vv_inside_bbox") {
{
  SbViewVolume vv;
  vv.ortho(-0.5, 0.5, -0.5, 0.5, 0, 5);
  SbBox3f box(-10, -10, -10, 10, 10, 10);

  SbBox3f isect = vv.intersectionBox(box);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMin()[0], -0.5f);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMin()[1], -0.5f);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMin()[2], -5.0f);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMax()[0], 0.5f);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMax()[1], 0.5f);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMax()[2], 0.0f);
    }

    SECTION("intersect_perspective") {
{
  // FIXME: set up a better perspective vv which also tests left/right/top/bottom
  SbViewVolume vv;
  vv.perspective(0.78f, 1.0f, 4.25, 4.75);
  vv.translateCamera(SbVec3f(0.0f, 0.0f, 5.0f));

  SbBox3f box(0, 0, 0, 1, 1, 1);
  SbBox3f isect = vv.intersectionBox(box);

  COIN_TESTCASE_CHECK_FLOAT(isect.getMin()[0], 0.0);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMin()[1], 0.0f);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMin()[2], 0.25f);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMax()[0], 1.0f);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMax()[1], 1.0f);
  COIN_TESTCASE_CHECK_FLOAT(isect.getMax()[2], 0.75f);
    }
}

// Tests for SbBox3f (from src/base/SbBox3f.cpp)



TEST_CASE("SbBox3f tests", "[base][SbBox3f]") {
    CoinTestFixture fixture;

    SECTION("checkGetClosestPoint") { {
  SbVec3f point(1524 , 13794 , 851);
  SbVec3f min(1557, 3308, 850);
  SbVec3f max(3113, 30157, 1886);

  SbBox3f box(min, max);
  SbVec3f expected(1557, 13794, 851);

  BOOST_CHECK_MESSAGE(box.getClosestPoint(point) == expected,
                      "Closest point does not fit");

  SbVec3f sizes = box.getSize();
  SbVec3f expectedCenterQuery(sizes[0]/2.0f, sizes[1]/2.0f, max[2]);

  BOOST_CHECK_MESSAGE(box.getClosestPoint(box.getCenter()) == expectedCenterQuery,
                      "Closest point for center query does not fit");
    }
}

// Tests for SbByteBuffer (from src/base/SbByteBuffer.cpp)
#include <Inventor/SbByteBuffer.h>
#include <string>

TEST_CASE("SbByteBuffer tests", "[base][SbByteBuffer]") {
    CoinTestFixture fixture;


    SECTION("pushUnique") {
{

  static const char A [] = "ABC";
  static const char B [] = "XYZ";
  static char C [sizeof(A)+sizeof(B)-1];
  strcpy(C,A);
  strcat(C,B);

  SbByteBuffer a(sizeof(A)-1,A);
  SbByteBuffer b(sizeof(B)-1,B);
  SbByteBuffer c=a;

  c.push(b);

  bool allOk=true;
  for (size_t i=0;i<sizeof(A)-1;++i) {
    if (a[i]!=A[i])
      allOk=false;
  }
  for (size_t i=0;i<sizeof(B)-1;++i) {
    if (b[i]!=B[i])
      allOk=false;
  }
          CHECK_WITH_MESSAGE(c.size()==sizeof(C)-1, "Concatenation does not have correct size");
  for (size_t i=0;i<sizeof(C)-1;++i) {
    if (c[i]!=C[i])
      allOk=false;
  }

  BOOST_CHECK_MESSAGE(allOk,
                      std::string("Concatenation of ") + A + " and " + B + " is not " + C
                      );
    }

    SECTION("pushOnEmpty") {
{
  SbByteBuffer a;
  SbByteBuffer b("foo");

  BOOST_CHECK_MESSAGE(a.empty(),
                      std::string("Size of empty buffer is") + std::to_string(a.size())
                      );

  a.push(b);

  BOOST_CHECK_MESSAGE(a.size() == b.size(),
                      "Size of buffers differ"
                      );

  for (size_t i=0; i < b.size(); ++i) {
    if(a[i]!=b[i]) {
      printf("Mjau %lu: %c != %c \n",(unsigned long)i,a[i],b[i]);
    }
  }

  BOOST_CHECK_MESSAGE(a == b,
                      "Byte representations differ"
                      );

    }
}

// Tests for SbDPPlane (from src/base/SbDPPlane.cpp)



TEST_CASE("SbDPPlane tests", "[base][SbDPPlane]") {
    CoinTestFixture fixture;



using namespace SIM::Coin::TestSuite;

float slew(float Start, float End, int steps, int step) {
  const float S = log(Start<0?-Start:Start);
  const float E = log(End<0?-End:End);

  --steps;

  float res=0;

  assert(Start<End);

  if (Start<0 && End < 0 ) {
    res=-exp(S+step*(E-S)/steps);
  }
  else if(Start>0 && End>0) {
    res=exp(S+step*(E-S)/steps);
  }
  else {
    float ZeroPoint = S*steps/(E+S);
    if(step<ZeroPoint) {
      res=-exp(S-2*step*S/ZeroPoint);
    }
    else if (step==ZeroPoint) {
      res=0;
    }
    else {
      res=exp(2*E*(step-ZeroPoint)/(steps-ZeroPoint)-E);
    }
  }

  return res;
    }

    SECTION("signCorrect") {
{
  SbDPPlane plane1(SbVec3d(0.0, 0.0, 1.0), 3.0);
  SbDPPlane plane2(SbVec3d(1.0, 0.0, 0.0), 21.0);
  SbDPLine line;
  plane1.intersect(plane2, line); 

  SbVec3d intersect = line.getPosition();
  SbVec3d vec(21, 0, 3);

  check_compare(intersect,vec, "SbDPPlane SignCorrect", .1f);
    }

    SECTION("equalityToFloatPlane") {
{
  const float delX = 1;
  const float delY = .1f;

  const float XMax = (float)pow(2.,FLT_MAX_EXP/3.);
  const float XMin = -XMax;

  const float YMax = (float)pow(2.,FLT_MAX_EXP/3.);
  const float YMin = -YMax;

#ifdef TEST_SUITE_QUICK
  const int XSteps = 4;
  const int YSteps = 4;
#endif //TEST_SUITE_QUICK
#ifdef TEST_SUITE_THOROUG
  const int XSteps = 6;
  const int YSteps = 6;
#endif //TEST_SUITE_THOROUG
#ifdef TEST_SUITE_EXPANSIVE
  const int XSteps = 10;
  const int YSteps = 10;
#endif //TEST_SUITE_EXPANSIVE

  int count=0;
 
  for (int x1=0;x1<XSteps;++x1) {
    float X1=slew(XMin,XMax,XSteps,x1);
    for (int x2=0;x2<XSteps;++x2) {
      float X2=slew(XMin,XMax,XSteps,x2);
      for (int x3=0;x3<XSteps;++x3) {
        float X3=slew(XMin,XMax,XSteps,x3);
        SbVec3f fv1(X1,X2,X3);
        SbVec3d dv1(X1,X2,X3);
        
        for (int x4=0;x4<XSteps;++x4) {
          float X4=slew(XMin,XMax,XSteps,x4);

          SbPlane fp1(fv1,X4);
          SbDPPlane dp1(dv1,X4);

          check_compare(fp1.getDistanceFromOrigin(),dp1.getDistanceFromOrigin(), "Distance from origin differs", 64);
          check_compare(fp1.getNormal(),dp1.getNormal(),"Comparing normals yields different results",.000001f);
          for (int y1=0;y1<YSteps;++y1) {
            float Y1=slew(YMin,YMax,YSteps,y1);
            for (int y2=0;y2<YSteps;++y2) {
              float Y2=slew(YMin,YMax,YSteps,y2);
              for (int y3=0;y3<YSteps;++y3) {
                float Y3=slew(YMin,YMax,YSteps,y3);
                SbVec3f fv2(Y1,Y2,Y3);
                SbVec3d dv2(Y1,Y2,Y3);

                //A bit arbitrary, this holds
                const float tol = .03f;
                BOOST_CHECK_MESSAGE(
                                    floatEquals(fp1.getDistance(fv2),(float)dp1.getDistance(dv2),tol)||
                                    fabs(fp1.getDistance(fv2)-dp1.getDistance(dv2))/fabs(dp1.getDistanceFromOrigin())<tol,
                                    "Distance from plane is significantly different");
                for (int y4=0;y4<YSteps;++y4) {
                  float Y4=slew(YMin,YMax,YSteps,y3);
                  SbPlane fp2(fv2,Y4);
                  SbDPPlane dp2(dv2,Y4);

                  SbLine fLine;
                  SbDPLine dLine;
                  bool failed=false;
                  if (!fp1.intersect(fp2, fLine)) {
                    failed = true;
                  }
                  if (!dp1.intersect(dp2, dLine)) {
                            CHECK_WITH_MESSAGE(failed, "Float intersection worked, but double intersection failed");
                    failed = true;
                  }
                  if (failed)
                    continue;


                  SbVec3f fDir(fLine.getDirection());
                  SbVec3d dDir(dLine.getDirection());

                  check_compare(fDir,dDir, "Intersection direction differs", .004f);
                }
              }
            }
          }
        }
      }
    }
  }
  
    }
}

// Tests for SbBox3d (from src/base/SbBox3d.cpp)



TEST_CASE("SbBox3d tests", "[base][SbBox3d]") {
    CoinTestFixture fixture;

    SECTION("checkGetClosestPoint") { {
    SbVec3d point(1524, 13794, 851);
    SbVec3d min(1557, 3308, 850);
    SbVec3d max(3113, 30157, 1886);

    SbBox3d box(min, max);
    SbVec3d expected(1557, 13794, 851);

    BOOST_CHECK_MESSAGE(box.getClosestPoint(point) == expected,
        "Closest point does not fit");

    SbVec3d sizes = box.getSize();
    SbVec3d expectedCenterQuery(sizes[0] / 2.0, sizes[1] / 2.0, max[2]);

    BOOST_CHECK_MESSAGE(box.getClosestPoint(box.getCenter()) == expectedCenterQuery,
        "Closest point for center query does not fit");
    }
}

// Tests for heap (from src/base/heap.cpp)



TEST_CASE("heap tests", "[base][heap]") {
    CoinTestFixture fixture;

class mock_up {
public:
  typedef struct wrapped_value {
    double x;
  } wrapped_value;

  static void heap_print_cb(void * v, SbString& str) {
    wrapped_value* value = reinterpret_cast<wrapped_value*>(v);
    str += std::to_string(static_cast<int>(value->x)).c_str();
  }

  static double heap_evaluate_cb(void * v)
  {
    wrapped_value* value = reinterpret_cast<wrapped_value*>(v);
    return value->x;
  }

  // strict weak ordering is needed for compare callbacks
  static int min_heap_compare_cb(void * lhs, void * rhs)
  {
    return heap_evaluate_cb(lhs) < heap_evaluate_cb(rhs) ? 1 : 0;
  }

  static int max_heap_compare_cb(void * lhs, void * rhs)
  {
    return heap_evaluate_cb(lhs) > heap_evaluate_cb(rhs) ? 1 : 0;
  }
    };

    SECTION("min_heap") { {
  mock_up::wrapped_value val[] = {3, 2, 1, 15, 5, 4, 45};
  cc_heap* heap = cc_heap_construct(256, reinterpret_cast<cc_heap_compare_cb*>(mock_up::min_heap_compare_cb), TRUE);
  for (int i = 0, n = sizeof(val) / sizeof(val[0]); i < n; ++i)
    cc_heap_add(heap, &val[i]);
  SbString result;
  cc_heap_print(heap, reinterpret_cast<cc_heap_print_cb*>(mock_up::heap_print_cb), result, FALSE);
  cc_heap_destruct(heap);
  heap = NULL;
  SbString str("1 3 2 15 5 4 45 ");
  BOOST_CHECK_MESSAGE(str == result,
    std::string("Mismatch between ") + result.getString() + " and control string " + str.getString());
    }

    SECTION("max_heap") { {
  mock_up::wrapped_value val[] = {3, 2, 1, 15, 5, 4, 45};
  cc_heap* heap = cc_heap_construct(256, reinterpret_cast<cc_heap_compare_cb*>(mock_up::max_heap_compare_cb), TRUE);
  for (int i = 0, n = sizeof(val) / sizeof(val[0]); i < n; ++i)
    cc_heap_add(heap, &val[i]);
  SbString result;
  cc_heap_print(heap, reinterpret_cast<cc_heap_print_cb*>(mock_up::heap_print_cb), result, FALSE);
  cc_heap_destruct(heap);
  heap = NULL;
  SbString str("45 5 15 2 3 1 4 ");
  BOOST_CHECK_MESSAGE(str == result,
    std::string("Mismatch between ") + result.getString() + " and control string " + str.getString());
    }

    SECTION("heap_add") { {
  mock_up::wrapped_value val[] = {3, 2, 1, 15, 5, 4, 45};
  cc_heap* heap = cc_heap_construct(256, reinterpret_cast<cc_heap_compare_cb*>(mock_up::min_heap_compare_cb), TRUE);
  for (int i = 0, n = sizeof(val) / sizeof(val[0]); i < n; ++i)
    cc_heap_add(heap, &val[i]);
  double added_value = 12;
  cc_heap_add(heap, &added_value);
  SbString result;
  cc_heap_print(heap, reinterpret_cast<cc_heap_print_cb*>(mock_up::heap_print_cb), result, FALSE);
  cc_heap_destruct(heap);
  heap = NULL;
  SbString str("1 3 2 12 5 4 45 15 ");
  BOOST_CHECK_MESSAGE(str == result,
    std::string("Mismatch between ") + result.getString() + " and control string " + str.getString());
    }

    SECTION("heap_remove") { {
  mock_up::wrapped_value val[] = {3, 2, 1, 15, 5, 4, 45};
  cc_heap* heap = cc_heap_construct(256, reinterpret_cast<cc_heap_compare_cb*>(mock_up::min_heap_compare_cb), TRUE);
  for (int i = 0, n = sizeof(val) / sizeof(val[0]); i < n; ++i)
    cc_heap_add(heap, &val[i]);
  cc_heap_remove(heap, &val[3]);
  SbString result;
  cc_heap_print(heap, reinterpret_cast<cc_heap_print_cb*>(mock_up::heap_print_cb), result, FALSE);
  cc_heap_destruct(heap);
  heap = NULL;
  SbString str("1 3 2 45 5 4 ");
  BOOST_CHECK_MESSAGE(str == result,
    std::string("Mismatch between ") + result.getString() + " and control string " + str.getString());
    }

    SECTION("heap_update") { {
  mock_up::wrapped_value val[] = {3, 2, 1, 15, 5, 4, 45};
  cc_heap* heap = cc_heap_construct(256, reinterpret_cast<cc_heap_compare_cb*>(mock_up::min_heap_compare_cb), TRUE);
  for (int i = 0, n = sizeof(val) / sizeof(val[0]); i < n; ++i)
    cc_heap_add(heap, &val[i]);
  val[3].x = 1;
  cc_heap_update(heap, &val[3]);
  SbString result;
  cc_heap_print(heap, reinterpret_cast<cc_heap_print_cb*>(mock_up::heap_print_cb), result, FALSE);
  cc_heap_destruct(heap);
  heap = NULL;
  SbString str("1 1 2 3 5 4 45 ");
  BOOST_CHECK_MESSAGE(str == result,
    std::string("Mismatch between ") + result.getString() + " and control string " + str.getString());
    }
}

// Tests for SbString (from src/base/SbString.cpp)



TEST_CASE("SbString tests", "[base][SbString]") {
    CoinTestFixture fixture;


static void * createInstance(void)
{
  return (void *)0x1234;
    }

    SECTION("testAddition") {
{
  SbString str1("First");
  SbString str2("Second");
  const char *cstr1 = "Erste";
  const char *cstr2 = "Zweite";

  SbString a = str1 + str2;
  SbString b = cstr1 + str2;
  SbString c = str1 + cstr2;

  BOOST_CHECK_MESSAGE(a == SbString("FirstSecond"),
                      "operator+ error");
  BOOST_CHECK_MESSAGE(b == SbString("ErsteSecond"),
                      "operator+ error");
  BOOST_CHECK_MESSAGE(c == SbString("FirstZweite"),
                      "operator+ error");
    }
}

// Tests for SbImage (from src/base/SbImage.cpp)



TEST_CASE("SbImage tests", "[base][SbImage]") {
    CoinTestFixture fixture;


    SECTION("copyConstruct") { 
{
  unsigned char buf [4];

  for (int i=0;i<sizeof(buf); ++i) {
    buf[i]=i;
  }

  SbImage bar(buf,SbVec2s(2,2),1);

  SbImage foo(bar);

  SbVec2s tmp1;
  int tmp2;


  for (size_t i=0;i<sizeof(buf); ++i) {
            CHECK_WITH_MESSAGE(foo.getValue(tmp1, tmp2)[i]==bar.getValue(tmp1,tmp2)[i],"Input value error");
  }

  for (size_t i=0;i<sizeof(buf); ++i) {
    foo.getValue(tmp1,tmp2)[i]=(unsigned char)(sizeof(buf)-i);
  }

  for (size_t i=0;i<sizeof(buf); ++i) {
            CHECK_WITH_MESSAGE(foo.getValue(tmp1, tmp2)[i]==sizeof(buf)-bar.getValue(tmp1,tmp2)[i],"Error after changing second buffer");
  }

    }
}

// Tests for SbVec4f (from src/base/SbVec4f.cpp)



TEST_CASE("SbVec4f tests", "[base][SbVec4f]") {
    CoinTestFixture fixture;


    SECTION("noNormalizingNormalized") {
{
  const float SQRT2 = sqrt(2.f)/2.f;
  SbVec4f vec(0,-SQRT2,0,SQRT2);

  vec.normalize();
  for (int i=0;i<4;++i) {
    int premultiply = ((i&0x1)*((i&0x2)-1));
    float testVal = premultiply*SQRT2;
    BOOST_CHECK_MESSAGE(
                        testVal==vec[i],
                        std::string("Wrong value when trying to access value #")
                        + std::to_string(i)
                        + ": "
                        + std::to_string(vec[i]) +
                        " == "
                        + std::to_string(testVal)
                        );
  }

    }

    SECTION("normalizingDeNormalized") {
{
  const int FLOAT_SENSITIVITY = 1;
  const float SQRT2 = sqrt(2.f)/2.f;
  SbVec4f vec(0,-1,0,1);

  vec.normalize();
  for (int i=0;i<4;++i) {
    int premultiply = ((i&0x1)*((i&0x2)-1));
    float testVal = premultiply*SQRT2;
    BOOST_CHECK_MESSAGE(
                        floatEquals(testVal,vec[i],FLOAT_SENSITIVITY),
                        std::string("Wrong value when trying to access value #")
                        + std::to_string(i)
                        + ": "
                        + std::to_string(vec[i]) +
                        " == "
                        + std::to_string(testVal)
                        );
  }

    }
}

// Tests for SbVec3s (from src/base/SbVec3s.cpp)



TEST_CASE("SbVec3s tests", "[base][SbVec3s]") {
    CoinTestFixture fixture;


typedef SbVec3s ToTest;
    SECTION("toString") { {
  ToTest val(1,2,3);
  SbString str("1 2 3");
  BOOST_CHECK_MESSAGE(str == val.toString(),
                      std::string("Mismatch between ") +  val.toString().getString() + " and control string " + str.getString());
    }

    SECTION("fromString") { {
  ToTest foo;
  SbString test = "1 -2 3";
  ToTest trueVal(1,-2,3);
  foo.fromString(test);
  BOOST_CHECK_MESSAGE(trueVal == foo,
                      std::string("Mismatch between ") +  foo.toString().getString() + " and control " + trueVal.toString().getString());
    }

    SECTION("fromInvalidString") { {
  ToTest foo;
  SbString test = "a,2,3";
  SbBool conversionOk = foo.fromString(test);
  BOOST_CHECK_MESSAGE(conversionOk == FALSE,
                      std::string("Able to convert from ") + test.getString() + " which is not a valid " + SbTypeInfo<ToTest>::getTypeName() + " representation");
    }
}

