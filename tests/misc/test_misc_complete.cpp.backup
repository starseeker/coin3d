/**************************************************************************\
 * Copyright (c) Kongsberg Oil & Gas Technologies AS
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * 
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 
 * Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
\**************************************************************************/

#include "utils/test_common.h"

using namespace CoinTestUtils;

// Complete migrated tests for misc module

// Tests for SoType (from src/misc/SoType.cpp)



TEST_CASE("SoType tests", "[misc][SoType]") {
    CoinTestFixture fixture;


static void * createInstance(void)
{
  return (void *)0x1234;
    }

    SECTION("testRemoveType") {
{
  BOOST_CHECK_MESSAGE(SoType::fromName(SbName("MyClass")) == SoType::badType(),
                      "Type didn't init to badType");
  SoType newtype = SoType::createType(SoNode::getClassTypeId(), SbName("MyClass"), createInstance, 0);
  BOOST_CHECK_MESSAGE(SoType::fromName(SbName("MyClass")) != SoType::badType(),
                      "Type didn't init correctly");
  bool success = SoType::removeType(SbName("MyClass"));
  BOOST_CHECK_MESSAGE(success,
                      "removeType() failed");
  BOOST_CHECK_MESSAGE(SoType::fromName(SbName("MyClass")) == SoType::badType(),
                      "Type didn't deregister correctly");
    }
}

// Tests for SoDB (from src/misc/SoDB.cpp)



TEST_CASE("SoDB tests", "[misc][SoDB]") {
    CoinTestFixture fixture;



/* Removed boost workaround include - no longer needed for C++17 */

    SECTION("globalRealTimeField") {
{
  //Need to do this here, since we do not have any manager that calls it for us.
  SoDB::getSensorManager()->processTimerQueue();
  SoSFTime * realtime = (SoSFTime *)SoDB::getGlobalField("realTime");

          REQUIRE(realtime != NULL);
          REQUIRE(realtime->getContainer() != NULL);

  // check that realtime field actually is initialized with something
  // close to actual time
  const double clockdiff =
    fabs(SbTime::getTimeOfDay().getValue() - realtime->getValue().getValue());
  BOOST_CHECK_MESSAGE(clockdiff < 5.0,
                      "realTime global field not close to actual time");
    }

// Do-nothing error handler for ignoring read errors while testing.
static void
readErrorHandler(const SoError * error, void * data)
{
    }

// DISABLED: These tests depend on VRML2 support which has been removed
// in this stripped version of Coin3D
/*
    SECTION("readChildList") {
{
  static const char scene[] = "#VRML V2.0 utf8\n"
                              "DEF TestGroup Group { children [Group{}, Group{}, Group{}] }";
  SoInput in;
  in.setBuffer(scene, strlen(scene));
  SoSeparator * root = SoDB::readAll(&in);
          REQUIRE(root);
  root->ref();
  SoGroup * group = (SoGroup *) SoNode::getByName("TestGroup");
  BOOST_REQUIRE_MESSAGE(group->getNumChildren() == 3, "Unexpected number of children");
  for (int i = 0; i < group->getNumChildren(); i++) {
    BOOST_REQUIRE_MESSAGE(group->getChild(i)->isOfType(SoGroup::getClassTypeId()), "Unexpected type");
  }
  root->unref();
    }

    SECTION("readEmptyChildList") {
{
  // FIXME: We are forced to restore the global state before terminating,
  // or independent tests could fail. (sveinung 20071108)
  SoErrorCB * prevErrorCB = SoReadError::getHandlerCallback();
  SoReadError::setHandlerCallback(readErrorHandler, NULL);

  static const char scene[] = "#VRML V2.0 utf8\n"
                              "DEF TestGroup Group { children }";
  SoInput in;
  in.setBuffer(scene, strlen(scene));
  SoSeparator * root = SoDB::readAll(&in);
  if (root) {
    SoGroup * group = (SoGroup *) SoNode::getByName("TestGroup");
            CHECK_WITH_MESSAGE(group->getNumChildren() == 0, "Should have no children");
  }
          CHECK_WITH_MESSAGE(root == NULL, "Expected the import to fail");

  SoReadError::setHandlerCallback(prevErrorCB, NULL);
    }

    SECTION("readNullChildList") {
{
  // FIXME: We are forced to restore the global state before terminating,
  // or independent tests could fail. (sveinung 20071108)
  SoErrorCB * prevErrorCB = SoReadError::getHandlerCallback();
  SoReadError::setHandlerCallback(readErrorHandler, NULL);

  static const char scene[] = "#VRML V2.0 utf8\n"
                              "PROTO Object [ field MFNode testChildren NULL ] { }\n"
                              "DEF TestObject Object { }";
  SoInput in;
  in.setBuffer(scene, strlen(scene));
  SoSeparator * root = SoDB::readAll(&in);
  if (root) {
    SoNode * object = (SoNode *) SoNode::getByName("TestObject");
    SoMFNode * field = (SoMFNode *) object->getField("testChildren");
            CHECK_WITH_MESSAGE(field->getNumNodes() == 0, "Should have no children");
  }
          CHECK_WITH_MESSAGE(root == NULL, "Expected the import to fail");

  SoReadError::setHandlerCallback(prevErrorCB, NULL);
    }

    SECTION("readInvalidChildList") {
{
  // FIXME: We are forced to restore the global state before terminating,
  // or independent tests could fail. (sveinung 20071108)
  SoErrorCB * prevErrorCB = SoReadError::getHandlerCallback();
  SoReadError::setHandlerCallback(readErrorHandler, NULL);

  static const char scene[] = "#VRML V2.0 utf8\n"
                              "Group { children[0] }";
  SoInput in;
  in.setBuffer(scene, strlen(scene));
  SoSeparator * root = SoDB::readAll(&in);
          CHECK_WITH_MESSAGE(root == NULL, "Expected the import to fail");

  SoReadError::setHandlerCallback(prevErrorCB, NULL);
    }
*/

    SECTION("testAlternateRepNull") {
{
  // FIXME: We are forced to restore the global state before terminating,
  // or independent tests could fail. (sveinung 20071108)
  SoErrorCB * prevErrorCB = SoReadError::getHandlerCallback();
  SoReadError::setHandlerCallback(readErrorHandler, NULL);

  static const char scene[] = "#Inventor V2.1 ascii\n"
                              "ExtensionNode { fields [ SFNode alternateRep ] }";
  SoInput in;
  in.setBuffer(scene, strlen(scene));
  SoSeparator * root = SoDB::readAll(&in);
          CHECK_WITH_MESSAGE(root, "Import should succeed");
  root->ref();
  root->unref();

  SoReadError::setHandlerCallback(prevErrorCB, NULL);
    }

    SECTION("testInitCleanup") {
{
  // init already called
  SoDB::finish();

  SoDB::init();
  SoDB::finish();


  //FIXME: This is not a true unittest, as it touches state for other functions.
  // init for the conntinuing test running
  SoDB::init();
  SoInteraction::init();
  SIM::Coin3D::Coin::TestSuite::Init();

    }

// *************************************************************************

// Tests whether or not our mechanisms with the realTime global field
// works correctly upon references to it in imported iv-files.
//
// (This test might be better suited in the SoGlobalField.cpp file,
// but that code doesn't implement a public API part, which causes
// hickups for the automated test-suite code-grabbing & setup.)
//
// -mortene

    SECTION("globalfield_import") {
{
  char scene[] =
    "#Inventor V2.1 ascii\n\n"
    "DEF rotnode RotationXYZ {"
    "   angle = GlobalField {"
    "      type \"SFTime\""
    "      realTime 0"
    "   }"
    "   . realTime "
    "}";

  SoInput * in = new SoInput;
  in->setBuffer(scene, strlen(scene));
  SoNode * g = NULL;
  const SbBool readok = SoDB::read(in, g);

  delete in;

  // just to see that we're correct with the syntax
  BOOST_CHECK_MESSAGE(readok,
                      "failed to read scene graph with realTime global field");
  if (!readok) { return; }

  g->ref();

  SoSFTime * realtime = (SoSFTime *)SoDB::getGlobalField("realTime");

  // supposed to get new value from file
  BOOST_CHECK_MESSAGE(realtime->getValue().getValue() == 0.0,
                      "realTime global field value not updated from imported value");

  SoRotationXYZ * r = (SoRotationXYZ *)
    SoBase::getNamedBase("rotnode", SoRotationXYZ::getClassTypeId());
  assert(r);

  // check connection
  SoField * master;
  BOOST_CHECK_MESSAGE((r->angle.getNumConnections() == 1) &&
                      r->angle.getConnectedField(master) &&
                      (master == realtime),
                      "connection to realTime global field not set up properly");

  g->unref();
    }

// *************************************************************************
}

// Tests for SoBase (from src/misc/SoBase.cpp)



TEST_CASE("SoBase tests", "[misc][SoBase]") {
    CoinTestFixture fixture;


/*This test targets the implementation of SoWriterefCounter::getWriteName
  in the source file SoWriterefCounter.cpp. Test is put here because the
  SoWriterefCounter class is not part of the public API. It is being called
  from here 
  */


 static char * buffer;
  static size_t buffer_size = 0;

//
// If function is copied from SoWriterefCounter.cpp as pricate classes cannot be called from the test suite
//
  static SbBool
dont_mangle_output_names(const SoBase *base)
{
  static int COIN_DONT_MANGLE_OUTPUT_NAMES = -1;

  // Always unmangle node names in VRML1 and VRML2
  if (base->isOfType(SoNode::getClassTypeId()) &&
      (((SoNode *)base)->getNodeType()==SoNode::VRML1 ||
     ((SoNode *)base)->getNodeType()==SoNode::VRML2)) return TRUE;

  if (COIN_DONT_MANGLE_OUTPUT_NAMES < 0) {
    COIN_DONT_MANGLE_OUTPUT_NAMES = 0;
    const char * env = coin_getenv("COIN_DONT_MANGLE_OUTPUT_NAMES");
    if (env) COIN_DONT_MANGLE_OUTPUT_NAMES = atoi(env);
  }
  return COIN_DONT_MANGLE_OUTPUT_NAMES ? TRUE : FALSE;
    }

  static void *
  buffer_realloc(void * bufptr, size_t size)
  {
    buffer = (char *)realloc(bufptr, size);
    buffer_size = size;
    return buffer;
  }


    SECTION("checkWriteWithMultiref") {
{
	SoDB::init();
	   SoNode* scenegraph;
       SoSeparator *root = new SoSeparator;
       root->ref();
       root->setName("root");
		scenegraph = root;
       SoSeparator *n0 = new SoSeparator;
       SoSeparator *a0 = new SoSeparator;
       SoSeparator *a1 = new SoSeparator;
       SoSeparator *a2 = new SoSeparator;
       SoSeparator *a3 = new SoSeparator;
       SoSeparator *b0 = new SoSeparator;
       SoSeparator *b1 = new SoSeparator;
       SoSeparator *b2 = new SoSeparator;
       SoSeparator *b3 = new SoSeparator;
       SoSeparator *b4 = new SoSeparator;
       SoSeparator *c0 = new SoSeparator;

       a2->setName(SbName("MyName"));
       b0->setName(SbName("MyName"));
       b1->setName(SbName("MyName"));
       b2->setName(SbName("MyName"));
       b4->setName(SbName("MyName"));
       c0->setName(SbName("MyName"));

       root->addChild(n0);
       root->addChild(n0);
       root->addChild(a0);
       a0->addChild(b0);
       a0->addChild(b1);
       root->addChild(b0);
       root->addChild(a1);
       a1->addChild(b2);
       a1->addChild(b1);
       root->addChild(b1);
       root->addChild(a2);
       root->addChild(a2);
       root->addChild(a3);
       a3->addChild(b3);
       b3->addChild(c0);
       b3->addChild(c0);
       a3->addChild(b4);
       a3->addChild(a2);



/*
       Correct output file if dont_mangle_names:

#VRML V1.0 ascii

VRMLGroup {
  children 
    DEF root VRMLGroup {
      children [ 
        DEF _+0 VRMLGroup {
        },
        USE _+0,
        DEF _+1 VRMLGroup {
          children [ 
            DEF MyName VRMLGroup {
            },
            DEF MyName+2 VRMLGroup {
            } ]
        },
        USE MyName,
        DEF _+3 VRMLGroup {
          children [ 
            DEF MyName+4 VRMLGroup {
            },
            USE MyName+2 ]
        },
        USE MyName+2,
        DEF MyName+5 VRMLGroup {
        },
        USE MyName+5,
        DEF _+6 VRMLGroup {
          children [ 
            DEF _+7 VRMLGroup {
              children [ 
                DEF MyName+8 VRMLGroup {
                },
                USE MyName+8 ]
            },
            DEF MyName+9 VRMLGroup {
            },
            USE MyName+5 ]
        } ]
    }
    }
    */

	   /* correct outputfile for default OIV behavior:
#VRML V1.0 ascii

DEF root Separator {
  DEF _+0 Separator {
  }
  USE _+0
  Separator {
    DEF MyName Separator {
    }
    DEF MyName+1 Separator {
    }
  }
  USE MyName
  Separator {
    DEF MyName+2 Separator {
    }
    USE MyName+1
  }
  USE MyName+1
  DEF MyName+3 Separator {
  }
  USE MyName+3
  Separator {
    Separator {
      DEF MyName+4 Separator {
      }
      USE MyName+4
    }
    DEF MyName+5 Separator {
    }
    USE MyName+3
  }
    }
*/
	   // DISABLED: VRML2 conversion functionality has been removed 
	   // Only test the standard Inventor output now
	   for(int j=0;j<1;j++) {
		   // Skip VRML2 conversion since it's been removed
		   if(j==1) {
			   continue;
		   }


	   buffer = (char*)malloc(1024);
       SoOutput out;
       // out.openFile("out.wrl"); 
	   out.setBuffer(buffer, 1024,buffer_realloc);
       out.setHeaderString(SbString("#Inventor V2.1 ascii"));
       SoWriteAction wra(&out);
       wra.apply(scenegraph);
	   SbString s(buffer);
	   free(buffer);

	   int pos;
	   SbString ss;

	   SbList<SbString> node_names(15);
	   // Since VRML2 conversion is disabled, we always use standard behavior
	           CHECK_WITH_MESSAGE(dont_mangle_output_names(scenegraph)==FALSE, "don't mangle should be FALSE");

	   // Use standard Inventor node names (VRML2 conversion disabled)
	   {
		   node_names.append("_+0");
		   node_names.append("_+0");
		   node_names.append("MyName");
		   node_names.append("MyName+1");
		   node_names.append("MyName");
		   node_names.append("MyName+2");
		   node_names.append("MyName+1");
		   node_names.append("MyName+1");
		   node_names.append("MyName+3");
		   node_names.append("MyName+3");
		   node_names.append("MyName+4");
		   node_names.append("MyName+4");
		   node_names.append("MyName+5");
		   node_names.append("MyName+3");
	   }
   
	   int list_index = 0;
	   SbBool fail = false;
	   ss = s;
	   for(int i=0;i<node_names.getLength();i++) {
		   pos = ss.find(node_names[i]);
		   if(pos==-1) {
			   fail = true;
			   break;
		   }
		   ss = ss.getSubString(pos+node_names[i].getLength(),ss.getLength());
	   }


	           CHECK_WITH_MESSAGE(!fail, "Check failed, written node names should match test template");
	   
	   } // end for loop
	   
	
       root->unref();

 } // end test case
}

// Tests for SoBaseP (from src/misc/SoBaseP.cpp)



TEST_CASE("SoBaseP tests", "[misc][SoBaseP]") {
    CoinTestFixture fixture;



// Tests whether or not our mechanisms with the realTime field works
// correctly upon references to it in imported iv-files.
//
// (Added this test when it was suspected that a new realTime
// globalfield was made upon import due to bug(s) in
// SoBase::PImpl::readBaseInstance()).
//
// -mortene

    SECTION("realTime_globalfield_import") {
{
  // SoDB::init() already called by test-suite init, and the realTime
  // global field will be set up there

  //Store away the state before we mess with the global realTime field
  SoSFTime * realtime = (SoSFTime *)SoDB::getGlobalField("realTime");
  assert(realtime);
  SbTime realTimeStorage = realtime->getValue();

  char scene[] =
    "#Inventor V2.1 ascii\n\n"
    "RotationXYZ {"
    "   angle = GlobalField {"
    "      type \"SFTime\""
    "      realTime 0"
    "   }"
    "   . realTime "
    "}";

  SoInput * in = new SoInput;
  in->setBuffer(scene, strlen(scene));
  SoNode * g = NULL;
  const SbBool readok = SoDB::read(in, g);
  assert(readok); // that import is ok is tested by a case in SoDB.cpp
  delete in;

  // check that the global field is still the same instance
  SoSFTime * realtimeafter = (SoSFTime *)SoDB::getGlobalField("realTime");
  BOOST_CHECK_MESSAGE(realtime == realtimeafter,
                      "internal realTime SoGlobalField value changed upon iv import");

  // clean up
  g->ref();
  g->unref();

  //Restore state
  realtime->setValue(realTimeStorage);

    }
}

