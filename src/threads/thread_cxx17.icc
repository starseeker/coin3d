/**************************************************************************\
 * Copyright (c) Kongsberg Oil & Gas Technologies AS
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * 
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 
 * Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
\**************************************************************************/

/*!
  \file thread_cxx17.icc
  \brief C++17 thread implementation replacing platform-specific pthread/win32 code
  
  This file provides portable C++17 thread implementation using std::thread,
  eliminating the need for separate pthread and win32 implementations.
*/

/* this file should only be included from thread.cpp */

#include <thread>
#include <memory>
#include <functional>

// Wrapper to convert C function pointer to std::function
static void * thread_wrapper_function(void * arg) {
  cc_thread * thread = static_cast<cc_thread *>(arg);
  return thread->func(thread->closure);
}

static int
internal_init(cc_thread * thread)
{
  try {
    // Create the std::thread and store it
    auto std_thread = std::make_unique<std::thread>(thread_wrapper_function, thread);
    
    // Store the std::thread pointer in the cxx17 union member
    thread->cxx17.thread_ptr = std_thread.release();
    
    return CC_OK;
  }
  catch (const std::exception& e) {
    if (COIN_DEBUG)
      cc_debugerror_post("internal_init", "std::thread creation error: %s\n", e.what());
    return CC_ERROR;
  }
}

static int
internal_clean(cc_thread * thread)
{
  try {
    if (thread->cxx17.thread_ptr) {
      std::thread* std_thread = static_cast<std::thread*>(thread->cxx17.thread_ptr);
      
      // If thread is still joinable, detach it to avoid std::terminate
      if (std_thread->joinable()) {
        std_thread->detach();
      }
      
      delete std_thread;
      thread->cxx17.thread_ptr = nullptr;
    }
    return CC_OK;
  }
  catch (const std::exception& e) {
    if (COIN_DEBUG)
      cc_debugerror_post("internal_clean", "std::thread cleanup error: %s\n", e.what());
    return CC_ERROR;
  }
}

static int
internal_join(cc_thread * thread, void ** retvalptr)
{
  try {
    if (!thread->cxx17.thread_ptr) {
      if (COIN_DEBUG)
        cc_debugerror_post("internal_join", "thread pointer is null\n");
      return CC_ERROR;
    }
    
    std::thread* std_thread = static_cast<std::thread*>(thread->cxx17.thread_ptr);
    
    if (!std_thread->joinable()) {
      if (COIN_DEBUG)
        cc_debugerror_post("internal_join", "thread is not joinable\n");
      return CC_ERROR;
    }
    
    std_thread->join();
    
    // Note: std::thread doesn't provide return value like pthread_join
    // The original code using pthread stored return values, but the C++17
    // approach typically uses other mechanisms (like std::future) for return values.
    // For compatibility, we set retval to nullptr if requested.
    if (retvalptr) {
      *retvalptr = nullptr;
    }
    
    return CC_OK;
  }
  catch (const std::exception& e) {
    if (COIN_DEBUG)
      cc_debugerror_post("internal_join", "std::thread join error: %s\n", e.what());
    return CC_ERROR;
  }
}