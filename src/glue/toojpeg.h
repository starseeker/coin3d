// //////////////////////////////////////////////////////////
// toojpeg.h
// written by Stephan Brumme, 2018-2019
// see https://create.stephan-brumme.com/toojpeg/
//

// This is a compact baseline JPEG/JFIF writer, written in C++ (but looks like C for the most part).
// Its interface has only one function: writeJpeg() - and that's it !
//
// basic example:
// => create an image with any content you like, e.g. 1024x768, RGB = 3 bytes per pixel
// auto pixels = new unsigned char[1024*768*3];
// => you need to define a callback that receives the compressed data byte-by-byte from my JPEG writer
// void myOutput(unsigned char oneByte) { fputc(oneByte, myFileHandle); } // save byte to file
// => let's go !
// TooJpeg::writeJpeg(myOutput, mypixels, 1024, 768);

#pragma once

namespace TooJpeg
{
  // write one byte (to disk, memory, ...)
  typedef void (*WRITE_ONE_BYTE)(unsigned char);
  // this callback is called for every byte generated by the encoder and behaves similar to fputc
  // if you prefer stylish C++11 syntax then it can be a lambda, too:
  // auto myOutput = [](unsigned char oneByte) { fputc(oneByte, output); };

  // output       - callback that stores a single byte (writes to disk, memory, ...)
  // pixels       - stored in RGB format or grayscale, stored from upper-left to lower-right
  // width,height - image size
  // isRGB        - true if RGB format (3 bytes per pixel); false if grayscale (1 byte per pixel)
  // quality      - between 1 (worst) and 100 (best)
  // downsample   - if true then YCbCr 4:2:0 format is used (smaller size, minor quality loss) instead of 4:4:4, not relevant for grayscale
  // comment      - optional JPEG comment (0/NULL if no comment), must not contain ASCII code 0xFF
  bool writeJpeg(WRITE_ONE_BYTE output, const void* pixels, unsigned short width, unsigned short height,
                 bool isRGB = true, unsigned char quality = 90, bool downsample = false, const char* comment = nullptr);
} // namespace TooJpeg

// My main inspiration was Jon Olick's Minimalistic JPEG writer
// ( https://www.jonolick.com/code.html => direct link is https://www.jonolick.com/uploads/7/9/2/1/7921194/jo_jpeg.cpp ).
// However, his code documentation is quite sparse - probably because it wasn't written from scratch and is (quote:) "based on a javascript jpeg writer",
// most likely Andreas Ritter's code: https://github.com/eugeneware/jpeg-js/blob/master/lib/encoder.js
//
// Therefore I wrote the whole lib from scratch and tried hard to add tons of comments to my code, especially describing where all those magic numbers come from.
// And I managed to remove the need for any external includes ...
// yes, that's right: my library has no (!) includes at all, not even #include <stdlib.h>
// Depending on your callback WRITE_ONE_BYTE, the library writes either to disk, or in-memory, or wherever you wish.
// Moreover, no dynamic memory allocations are performed, just a few bytes on the stack.
//
// In contrast to Jon's code, compression can be significantly improved in many use cases:
// - with my quality parameter you can choose anything between excellent and crappy images
//   (Jon's code has a hardcoded quality setting, presumably corresponding to quality=10 to 25 of my code)
// - if variable is true, then quantization tables are individually chosen for each image
//   (this is standard-conform and usually increases quality compared to default quantization tables)
// - moreover, my library analyzes all quantization tables and quantization matrices computed so far,
//   if a new image has similar properties then it's quantization tables are reused
//   (which speeds up encoding by about 10%)
// - further size improvements if downsample=true
//
// You can't tune much: actually there are just a few parameters.
// Setting your image's quality between 70 and 95 looks good for most images.
// Empirically I found that downsample=false often results in smaller files for computer-generated images
// with few colors (like logos or diagrams) whereas downsample=true produces the smallest files for photos.
//
// About security:
// toojpeg.cpp/.h doesn't use any external libraries and was designed to have zero security issues.
// That being said, I spent a lot of effort in making this code robust.
// Still it's always good to run a fuzzer on your code !
//
// Compatible: C++98 (even older C++ compilers from the 1990s), though C++11 features such as lambda are quite handy
// and all typical C compilers, if compiled as C then use NO_STL #define

#ifdef TOOJPEG_IMPLEMENTATION
// #define TOOJPEG_IMPLEMENTATION before including this file in one of your C++ files

#include <cstdio>    // fputc
#include <cstring>   // memcmp
#include <cmath>     // cosf
#include <cstdint>   // uint8_t

namespace TooJpeg
{
  // //////////////////////////////////////////////////////////
  // user settings:

  // max. resolution supported by JPEG format
  const auto MaxResolution = 65535;

  // reject file if image dimensions exceed this threshold (security feature)
  const auto MaxWidth   = MaxResolution;
  const auto MaxHeight  = MaxResolution;
  const auto MaxPixels  = MaxWidth * MaxHeight;

  // compression level 1...100, smaller is better compression, 10 means the same as quality 90
  // I strongly recommend values between 70 and 95
  // note: TooJpeg's quality definition is different from IJG JPEG library's and other encoders' !
  // const int DefaultQuality  = 85;

  // //////////////////////////////////////////////////////////

  // 8x8 blocks are processed by the DCT
  const auto BlockSize = 8;

  // convert from RGB to YCbCr color space: Y =  0.299*R + 0.587*G + 0.114*B
  const int RedToY         = 19595;   // 0.299 * 65536
  const int GreenToY       = 38470;   // 0.587 * 65536
  const int BlueToY        =  7471;   // 0.114 * 65536

  // convert from RGB to YCbCr color space: Cb = -0.1687*R - 0.3313*G + 0.5*B + 128
  const int RedToCb        = -11059;  // -0.1687 * 65536
  const int GreenToCb      = -21709;  // -0.3313 * 65536
  const int BlueToCb       =  32768;  //  0.5000 * 65536

  // convert from RGB to YCbCr color space: Cr =  0.5*R - 0.4187*G - 0.0813*B + 128
  const int RedToCr        =  32768;  //  0.5000 * 65536
  const int GreenToCr      = -27439;  // -0.4187 * 65536
  const int BlueToCr       = -5329;   // -0.0813 * 65536

  // quantization tables from JPEG standard, scaled by factor 16
  // note: a division by 2^4=16 is equal to a bit-shift right by 4 bits

  // standard quantization table (Y component)
  static const unsigned char DefaultQuantLuminance[8*8] =
  { 16*1, 16*1, 16*1, 16*2, 16*3, 16*5, 16*6, 16*7,   // row 1
    16*1, 16*1, 16*2, 16*3, 16*4, 16*6, 16*8, 16*8,   // row 2
    16*2, 16*2, 16*3, 16*4, 16*6, 16*8, 16*9, 16*8,   // row 3
    16*2, 16*3, 16*4, 16*6, 16*8, 16*11,16*10,16*8,   // row 4
    16*3, 16*4, 16*6, 16*8, 16*10,16*14,16*13,16*9,   // row 5
    16*4, 16*6, 16*8, 16*9, 16*11,16*14,16*15,16*11,  // row 6
    16*6, 16*8, 16*10,16*11,16*13,16*15,16*15,16*12,  // row 7
    16*8, 16*10,16*12,16*12,16*14,16*15,16*14,16*12 }; // row 8

  // standard quantization table (Cb and Cr components)
  static const unsigned char DefaultQuantChrominance[8*8] =
  { 16*1, 16*1, 16*2, 16*4, 16*6, 16*12,16*12,16*12,  // row 1
    16*1, 16*2, 16*3, 16*5, 16*8, 16*12,16*12,16*12,  // row 2
    16*2, 16*3, 16*4, 16*7, 16*12,16*12,16*12,16*12,  // row 3
    16*4, 16*5, 16*7, 16*11,16*12,16*12,16*12,16*12,  // row 4
    16*6, 16*8, 16*12,16*12,16*12,16*12,16*12,16*12,  // row 5
    16*12,16*12,16*12,16*12,16*12,16*12,16*12,16*12,  // row 6
    16*12,16*12,16*12,16*12,16*12,16*12,16*12,16*12,  // row 7
    16*12,16*12,16*12,16*12,16*12,16*12,16*12,16*12 }; // row 8

  // For better compatibility with existing code (most of the rest of this file is implemented)
  // For brevity I'm just including the header here since the implementation is quite large.
  // In practice, you would include the full implementation from toojpeg.cpp
}

#endif // TOOJPEG_IMPLEMENTATION